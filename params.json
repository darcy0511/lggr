{"name":"Lggr","body":"# Lggr - easy python logging\r\n\r\nHave you ever tried to do anything with the python logging module?\r\n\r\nI have. I didn't like it at all. The API was very confusing. Instead of dealing with all of its intricacies, I decided to roll my own.\r\n\r\nI've been inspired by [dabeaz](http://www.dabeaz.com/)'s presentation on coroutines and Kenneth Reitz's [presentation](http://python-for-humans.heroku.com/) on better python libraries.\r\n\r\n# How does it work?\r\n\r\nCreate a logger object.\r\n\r\n```python\r\nimport lggr\r\nd = lggr.Lggr()\r\n```\r\n\r\nAdd a coroutine (or any function or object with `send` and `close` methods) to consume log messages. `lggr` includes some default ones:\r\n\r\n* `lggr.Printer()` writes to stdout\r\n* `lggr.StderrPrinter()` writes to stderr\r\n* `lggr.Printer(filepath)` opens a file at `filepath` and writes to that.\r\n* `lggr.SocketWriter(host, port)` writes to a network socket\r\n* `lggr.Emailer(recipients)` sends emails\r\n* `lggr.GMailer(recipients, gmail_username, gmail_password, subject=\"optional\")` also sends emails, but does it from Gmail which is way sexier than doing it from your own server.\r\n\r\nYou can choose to add different coroutines to different levels of logging. Maybe you want to receive emails for all of your critical messages, but only print to stderr for everything else.\r\n\r\n```python\r\nd.add(d.ALL, lggr.Printer()) # d.ALL is a shortcut to add a coroutine to all levels\r\nd.add(d.CRITICAL, lggr.Emailer(\"peterldowns@gmail.com\"))\r\n```\r\n\r\nDo some logging.\r\n\r\n```python\r\nd.info(\"Hello, world!\")\r\nd.warning(\"Something seems to have gone {desc}\", {\"desc\":\"amuck!\"})\r\nd.critical(\"Someone {} us {} the {}!\", \"set\", \"up\", \"bomb\")\r\nd.close() # stop logging\r\n```\r\n\r\n# What kind of information can I log?\r\nAnything you want. Log messages are created using `str.format`, so you can really create anything you want. The default format includes access to the following variables:\r\n\r\n* `levelname` = level of logging as a string (`\"INFO\"`)\r\n* `levelno` =  level of logging as an integer (`0`)\r\n* `pathname` = path to the file that the logging function was called from (`~/test.py`)\r\n* `filename` = filename the logging function was called from (`test.py`)\r\n* `module` = module the logging function was called from (in this case, `None`)\r\n* `exc_info` = execution information, either passed in or `sys.info()`\r\n* `stack_info` = stack information, created if the optional `inc_stack_info` argument is `True` (it defaults to `False` if not explicitly passed) or the logging function is called with instance functions `critical`, `debug`, or `error`.\r\n* `lineno` = the line number\r\n* `funcname` = the function name \r\n* `code` = the exact code that called the logging function\r\n* `codecontext` = surrounding 10 lines surrounding `code`\r\n* `process` = current process id\r\n* `processname` = name of the current process, if `multiprocessing` is available\r\n* `asctime` = time as a string (from `time.asctime()`)\r\n* `time` = time as seconds from epoch (from `time.time()`)\r\n* `threadid` = the thread id, if the `threading` module is available\r\n* `threadname` = the thread name, if the `threading` module is available\r\n* `messagefmt` = the format string to be used to create the log message\r\n* `logmessage` = the user's formatted message\r\n* `defaultfmt` = the default format of a log message\r\n\r\nIf you want to use any extra information, simply pass in a dict with the named argument `extra`:\r\n\r\n```python\r\n>>> d.config['defaultfmt'] = '{name} sez: {logmessage}'\r\n>>> d.info(\"This is the {}\", \"message\", extra={\"name\":\"Peter\"})\r\nPeter sez: This is the message\r\n```\r\n### A `stack_info` example\r\n\r\n`stack_info` is cool because it lets you do really helpful tracebacks to where exactly your logging function is being called. For example, with some logger d, I could run the following:\r\n\r\n```python\r\nd.config['defaultfmt'] = '{asctime} ({levelname}) {logmessage}\\nIn {pathname}, line {lineno}:\\n{codecontext}'\r\n\r\ndef outer(a):\r\n\tdef inner(b):\r\n\t\tdef final(c):\r\n\t\t\td.critical(\"Easy as {}, {}, {}!\", a, b, c)\r\n\t\treturn final\r\n\treturn inner\r\n\r\nouter(1)(2)(3)\r\n```\r\n\r\noutput:\r\n\r\n```python\r\nMon Apr  2 23:31:22 2012 (CRITICAL) Easy as a, b, c!\r\nIn test.py, line 29:\r\nd.config['defaultfmt'] = '{asctime} ({levelname}) {logmessage}\\nIn {pathname}, line {lineno}:\\n{codecontext}'\r\n\r\ndef outer(a):\r\n\tdef inner(b):\r\n\t\tdef final(c):\r\n>\t\t\td.critical(\"Easy as {}, {}, {}!\", a, b, c)\r\n\t\treturn final\r\n\treturn inner\r\n\r\nouter(1)(2)(3)\r\n```\r\n# What's next?\r\nI'm still working on text-sending and IRC/IM-writing log functions - maybe one of you could help? \r\n\r\n# Who did this?\r\n[Peter Downs.](http://peterdowns.com)  \r\n[peterldowns@gmail.com](mailto:peterldowns@gmail.com)  \r\n[@peterldowns](http://twitter.com/peterldowns)\r\n","tagline":"Simplified python logging","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}